/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails oncall+recoil
 * @flow strict-local
 * @format
 */
'use strict';

import type { PersistenceType } from '../core/Recoil_Node';
import type { Snapshot } from '../core/Recoil_Snapshot';
import type { NodeKey, Store, TreeState } from '../core/Recoil_State';

const {
  batchUpdates
} = require('../core/Recoil_Batching');

const {
  DEFAULT_VALUE,
  getNode,
  nodes
} = require('../core/Recoil_Node');

const {
  useStoreRef
} = require('../core/Recoil_RecoilRoot');

const {
  AbstractRecoilValue,
  setRecoilValueLoadable
} = require('../core/Recoil_RecoilValueInterface');

const {
  SUSPENSE_TIMEOUT_MS
} = require('../core/Recoil_Retention');

const {
  cloneSnapshot
} = require('../core/Recoil_Snapshot');

const {
  useCallback,
  useEffect,
  useRef,
  useState
} = require('react');

const {
  isSSR
} = require('recoil-shared/util/Recoil_Environment');

const filterMap = require('recoil-shared/util/Recoil_filterMap');

const filterSet = require('recoil-shared/util/Recoil_filterSet');

const mapMap = require('recoil-shared/util/Recoil_mapMap');

const mergeMaps = require('recoil-shared/util/Recoil_mergeMaps');

const nullthrows = require('recoil-shared/util/Recoil_nullthrows');

const recoverableViolation = require('recoil-shared/util/Recoil_recoverableViolation');

const usePrevious = require('recoil-shared/util/Recoil_usePrevious');

declare function useTransactionSubscription(callback: (Store) => void): any;
declare function externallyVisibleAtomValuesInState(state: TreeState): Map<NodeKey, mixed>;
type ExternallyVisibleAtomInfo = {
  persistence_UNSTABLE: {
    type: PersistenceType,
    backButton: boolean,
    ...
  },
  ...
};
/**
  Calls the given callback after any atoms have been modified and the consequent
  component re-renders have been committed. This is intended for persisting
  the values of the atoms to storage. The stored values can then be restored
  using the useSetUnvalidatedAtomValues hook.

  The callback receives the following info:

  atomValues: The current value of every atom that is both persistable (persistence
              type not set to 'none') and whose value is available (not in an
              error or loading state).

  previousAtomValues: The value of every persistable and available atom before
               the transaction began.

  atomInfo: A map containing the persistence settings for each atom. Every key
            that exists in atomValues will also exist in atomInfo.

  modifiedAtoms: The set of atoms that were written to during the transaction.

  transactionMetadata: Arbitrary information that was added via the
          useSetUnvalidatedAtomValues hook. Useful for ignoring the useSetUnvalidatedAtomValues
          transaction, to avoid loops.
*/

declare function useTransactionObservation_DEPRECATED(callback: ({
  atomValues: Map<NodeKey, mixed>,
  previousAtomValues: Map<NodeKey, mixed>,
  atomInfo: Map<NodeKey, ExternallyVisibleAtomInfo>,
  modifiedAtoms: $ReadOnlySet<NodeKey>,
  transactionMetadata: {
    [NodeKey]: mixed,
    ...
  },
}) => void): any;
declare function useRecoilTransactionObserver(callback: ({
  snapshot: Snapshot,
  previousSnapshot: Snapshot,
}) => void): any; // Return a snapshot of the current state and subscribe to all state changes

declare function useRecoilSnapshot(): Snapshot;
declare function gotoSnapshot(store: Store, snapshot: Snapshot): void;
declare function useGotoRecoilSnapshot(): (Snapshot) => void;
module.exports = {
  useRecoilSnapshot,
  gotoSnapshot,
  useGotoRecoilSnapshot,
  useRecoilTransactionObserver,
  useTransactionObservation_DEPRECATED,
  useTransactionSubscription_DEPRECATED: useTransactionSubscription
};