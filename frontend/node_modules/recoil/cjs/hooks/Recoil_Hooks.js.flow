/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails oncall+recoil
 * @flow strict-local
 * @format
 */
'use strict';

import type { Loadable } from '../adt/Recoil_Loadable';
import type { DefaultValue } from '../core/Recoil_Node';
import type { RecoilState, RecoilValue } from '../core/Recoil_RecoilValue';
import type { ComponentSubscription } from '../core/Recoil_RecoilValueInterface';
import type { NodeKey } from '../core/Recoil_State';

const {
  batchUpdates
} = require('../core/Recoil_Batching');

const {
  DEFAULT_VALUE
} = require('../core/Recoil_Node');

const {
  reactMode,
  useMutableSource,
  useSyncExternalStore
} = require('../core/Recoil_ReactMode');

const {
  useRecoilMutableSource,
  useStoreRef
} = require('../core/Recoil_RecoilRoot');

const {
  isRecoilValue
} = require('../core/Recoil_RecoilValue');

const {
  AbstractRecoilValue,
  getRecoilValueAsLoadable,
  setRecoilValue,
  setUnvalidatedRecoilValue,
  subscribeToRecoilValue
} = require('../core/Recoil_RecoilValueInterface');

const useRetain = require('./Recoil_useRetain');

const {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState
} = require('react');

const {
  setByAddingToSet
} = require('recoil-shared/util/Recoil_CopyOnWrite');

const differenceSets = require('recoil-shared/util/Recoil_differenceSets');

const err = require('recoil-shared/util/Recoil_err');

const expectationViolation = require('recoil-shared/util/Recoil_expectationViolation');

const gkx = require('recoil-shared/util/Recoil_gkx');

const recoverableViolation = require('recoil-shared/util/Recoil_recoverableViolation');

const useComponentName = require('recoil-shared/util/Recoil_useComponentName');

declare function handleLoadable<T>(loadable: Loadable<T>, recoilValue: RecoilValue<T>, storeRef: any): T;
declare function validateRecoilValue<T>(recoilValue: RecoilValue<T>, hookName: any): any;
export type SetterOrUpdater<T> = (((T) => T) | T) => void;
export type Resetter = () => void;
export type RecoilInterface = {
  getRecoilValue: <T>(RecoilValue<T>) => T,
  getRecoilValueLoadable: <T>(RecoilValue<T>) => Loadable<T>,
  getRecoilState: <T>(RecoilState<T>) => [T, SetterOrUpdater<T>],
  getRecoilStateLoadable: <T>(RecoilState<T>) => [Loadable<T>, SetterOrUpdater<T>],
  getSetRecoilState: <T>(RecoilState<T>) => SetterOrUpdater<T>,
  getResetRecoilState: <T>(RecoilState<T>) => Resetter,
};
/**
 * Various things are broken with useRecoilInterface, particularly concurrent
 * mode, React strict mode, and memory management. They will not be fixed.
 * */

declare function useRecoilInterface_DEPRECATED(): RecoilInterface;
const recoilComponentGetRecoilValueCount_FOR_TESTING = {
  current: 0
};
declare function useRecoilValueLoadable_SYNC_EXTERNAL_STORE<T>(recoilValue: RecoilValue<T>): Loadable<T>;
declare function useRecoilValueLoadable_MUTABLE_SOURCE<T>(recoilValue: RecoilValue<T>): Loadable<T>;
declare function useRecoilValueLoadable_TRANSITION_SUPPORT<T>(recoilValue: RecoilValue<T>): Loadable<T>;
declare function useRecoilValueLoadable_LEGACY<T>(recoilValue: RecoilValue<T>): Loadable<T>;
/**
  Like useRecoilValue(), but either returns the value if available or
  just undefined if not available for any reason, such as pending or error.
*/

declare function useRecoilValueLoadable<T>(recoilValue: RecoilValue<T>): Loadable<T>;
/**
  Returns the value represented by the RecoilValue.
  If the value is pending, it will throw a Promise to suspend the component,
  if the value is an error it will throw it for the nearest React error boundary.
  This will also subscribe the component for any updates in the value.
  */

declare function useRecoilValue<T>(recoilValue: RecoilValue<T>): T;
/**
  Returns a function that allows the value of a RecoilState to be updated, but does
  not subscribe the component to changes to that RecoilState.
*/

declare function useSetRecoilState<T>(recoilState: RecoilState<T>): SetterOrUpdater<T>;
/**
  Returns a function that will reset the value of a RecoilState to its default
*/

declare function useResetRecoilState<T>(recoilState: RecoilState<T>): Resetter;
/**
  Equivalent to useState(). Allows the value of the RecoilState to be read and written.
  Subsequent updates to the RecoilState will cause the component to re-render. If the
  RecoilState is pending, this will suspend the component and initiate the
  retrieval of the value. If evaluating the RecoilState resulted in an error, this will
  throw the error so that the nearest React error boundary can catch it.
*/

declare function useRecoilState<T>(recoilState: RecoilState<T>): [T, SetterOrUpdater<T>];
/**
  Like useRecoilState(), but does not cause Suspense or React error handling. Returns
  an object that indicates whether the RecoilState is available, pending, or
  unavailable due to an error.
*/

declare function useRecoilStateLoadable<T>(recoilState: RecoilState<T>): [Loadable<T>, SetterOrUpdater<T>];
declare function useSetUnvalidatedAtomValues(): (values: Map<NodeKey, mixed>, transactionMetadata?: {...}) => void;
/**
 * Experimental variants of hooks with support for useTransition()
 */

declare function useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE<T>(recoilValue: RecoilValue<T>): Loadable<T>;
declare function useRecoilValue_TRANSITION_SUPPORT_UNSTABLE<T>(recoilValue: RecoilValue<T>): T;
declare function useRecoilState_TRANSITION_SUPPORT_UNSTABLE<T>(recoilState: RecoilState<T>): [T, SetterOrUpdater<T>];
module.exports = {
  recoilComponentGetRecoilValueCount_FOR_TESTING,
  useRecoilInterface: useRecoilInterface_DEPRECATED,
  useRecoilState,
  useRecoilStateLoadable,
  useRecoilValue,
  useRecoilValueLoadable,
  useResetRecoilState,
  useSetRecoilState,
  useSetUnvalidatedAtomValues,
  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,
  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,
  useRecoilState_TRANSITION_SUPPORT_UNSTABLE
};