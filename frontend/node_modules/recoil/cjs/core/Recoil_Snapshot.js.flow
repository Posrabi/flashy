/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails oncall+recoil
 * @flow strict-local
 * @format
 */
'use strict';

import type { Loadable } from '../adt/Recoil_Loadable';
import type { ResetRecoilState, SetRecoilState, ValueOrUpdater } from '../recoil_values/Recoil_callbackTypes';
import type { RecoilValueInfo } from './Recoil_FunctionalCore';
import type { NodeKey } from './Recoil_Keys';
import type { RecoilState, RecoilValue } from './Recoil_RecoilValue';
import type { StateID, Store, StoreState, TreeState } from './Recoil_State';

const {
  batchUpdates
} = require('./Recoil_Batching');

const {
  initializeNode,
  peekNodeInfo
} = require('./Recoil_FunctionalCore');

const {
  graph
} = require('./Recoil_Graph');

const {
  getNextStoreID
} = require('./Recoil_Keys');

const {
  DEFAULT_VALUE,
  recoilValues,
  recoilValuesForKeys
} = require('./Recoil_Node');

const {
  AbstractRecoilValue,
  getRecoilValueAsLoadable,
  setRecoilValue,
  setUnvalidatedRecoilValue
} = require('./Recoil_RecoilValueInterface');

const {
  updateRetainCount
} = require('./Recoil_Retention');

const {
  getNextTreeStateVersion,
  makeEmptyStoreState
} = require('./Recoil_State');

const concatIterables = require('recoil-shared/util/Recoil_concatIterables');

const {
  isSSR
} = require('recoil-shared/util/Recoil_Environment');

const err = require('recoil-shared/util/Recoil_err');

const filterIterable = require('recoil-shared/util/Recoil_filterIterable');

const gkx = require('recoil-shared/util/Recoil_gkx');

const mapIterable = require('recoil-shared/util/Recoil_mapIterable');

const {
  memoizeOneWithArgsHashAndInvalidation
} = require('recoil-shared/util/Recoil_Memoize');

const nullthrows = require('recoil-shared/util/Recoil_nullthrows');

const recoverableViolation = require('recoil-shared/util/Recoil_recoverableViolation'); // Opaque at this surface because it's part of the public API from here.


export type SnapshotID = StateID;
const retainWarning = `
Recoil Snapshots only last for the duration of the callback they are provided to. To keep a Snapshot longer, do this:

  const release = snapshot.retain();
  try {
    await doSomethingWithSnapshot(snapshot);
  } finally {
    release();
  }

This is currently a DEV-only warning but will become a thrown exception in the next release of Recoil.
`; // A "Snapshot" is "read-only" and captures a specific set of values of atoms.
// However, the data-flow-graph and selector values may evolve as selector
// evaluation functions are executed and async selectors resolve.

declare class Snapshot {
  _store: Store,
  _refCount: number,
  constructor(storeState: StoreState): any,
  retain(): () => void,
  autoRelease_INTERNAL(): void,
  _release(): void,
  isRetained(): boolean,
  checkRefCount_INTERNAL(): void,
  getStore_INTERNAL(): Store,
  getID(): SnapshotID,
  getLoadable: <T>(RecoilValue<T>) => Loadable<T>,
  getPromise: <T>(RecoilValue<T>) => Promise<T>,
  getNodes_UNSTABLE: ({
    isModified?: boolean,
    isInitialized?: boolean,
  } | void) => Iterable<RecoilValue<mixed>>,
  getInfo_UNSTABLE: <T>(RecoilValue<T>) => RecoilValueInfo<T>,
  map: ((MutableSnapshot) => void) => Snapshot,
  asyncMap: ((MutableSnapshot) => Promise<void>) => Promise<Snapshot>,
}
declare function cloneStoreState(store: Store, treeState: TreeState, bumpVersion: boolean): StoreState; // Factory to build a fresh snapshot

declare function freshSnapshot(initializeState?: (MutableSnapshot) => void): Snapshot; // Factory to clone a snapahot state

const [memoizedCloneSnapshot, invalidateMemoizedSnapshot] = memoizeOneWithArgsHashAndInvalidation((store, version) => {
  const storeState = store.getState();
  const treeState = version === 'current' ? storeState.currentTree : nullthrows(storeState.previousTree);
  return new Snapshot(cloneStoreState(store, treeState));
}, (store, version) => String(version) + String(store.storeID) + String(store.getState().currentTree.version) + String(store.getState().previousTree?.version));
declare function cloneSnapshot(store: Store, version: 'current' | 'previous'): Snapshot;
declare class MutableSnapshot extends Snapshot {
  _batch: (() => void) => void,
  constructor(snapshot: Snapshot, batch: (() => void) => void): any,
  set: SetRecoilState,
  reset: ResetRecoilState,
  setUnvalidatedAtomValues_DEPRECATED: (Map<NodeKey, mixed>) => void,
}
module.exports = {
  Snapshot,
  MutableSnapshot,
  freshSnapshot,
  cloneSnapshot
};